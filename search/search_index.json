{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Isomorphic Layout Composer (ILC) - a layout service that composes a web page from fragment services. It supports client/server-based page composition.</p> <p>Its competitive advantage over other solutions is an isomorphic page composition. It means that ILC assembles a page on the server-side using apps that support Server-side rendering (SSR), and after that, the page is passed on the client-side, so the client-side rendering handles all further navigation.</p> <p>This approach allows to combine advantages of the Micro Frontends, SPA, and Server-side rendering approaches.</p> <p>This repository also contains an example of how you can create a frontend that is composed from multiple applications that work in concert and deliver a unified experience.</p>"},{"location":"#why-do-i-need-ilc","title":"Why do I need ILC?","text":"<p>Microservices get a lot of traction these days. They allow multiple teams to work independently, choose their technology stacks, and establish release cycles. Unfortunately, frontend development doesn't take full advantage of the microservices' benefits. The common practice for building websites is still \"a monolith\" - a single frontend codebase that consumes multiple APIs.</p> <p>What if we introduce microservices on the frontend? It would allow frontend developers to work together with their backend counterparts on the same feature and independently deploy parts of the website (\"fragments\"), such as header, product, and footer. To bring microservices to the frontend, you need a layout service that can \"stitch\" a website out of fragments. This is where ILC comes into play.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>\ud83d\udce6 Based on single-spa and TailorX - battle-tested solutions inside.</li> <li>\ud83d\udcf1 Technology-agnostic - use it with React, Vue.js, Angular, etc.</li> <li>\u2699\ufe0f Server-side rendering (SSR) support - key advantage over competitors.</li> <li>\ud83d\uddc4 Built-in registry - add new apps, pages, or change configs and templates in a few clicks.</li> <li>\u26a1\ufe0f Built for speed - server-side part of the system adds just ~17ms of latency</li> <li>\ud83d\udc68\u200d\ud83d\udcbb Develop in production</li> <li>\ud83c\udf10 Internationalization support - serve your clients from any country.</li> <li>\ud83d\udce1 Advanced features:<ul> <li>Parcels</li> <li>Plugins</li> <li>App Wrappers</li> </ul> </li> <li>\ud83d\udcb2 Backed by Namecheap - we use it internally and plan to evolve it together with the community.</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick start","text":"<p>To quickstart with ILC locally, follow the steps below:</p> <ol> <li>Clone the namecheap/ilc repository.</li> <li>Run <code>npm install</code><ol> <li>OPTIONAL Switch database to PostgreSQL by changing environment variable <code>DB_CLIENT</code> to <code>pg</code> in services <code>registry_worker</code> and <code>registry</code> </li> </ol> </li> <li> <p>Run <code>docker compose up -d</code>. Wait for the process to complete:</p> <pre><code>[+] Running 6/6\n \u283f Network ilc_default                  Created     0.1s\n \u283f Container ilc-ilc-1                  Started     0.8s\n \u283f Container ilc-mysql-1                Started     0.8s\n \u283f Container ilc-registry-1             Started     20.0s\n \u283f Container ilc-demo-apps-1            Started     1.4s\n \u283f Container ilc-registry_worker-1      Started     19.8s\n</code></pre> </li> <li> <p>Run <code>docker compose run registry npm run seed</code>. Wait for the process to complete:</p> <pre><code>[+] Running 1/1\n \u283f Container ilc-mysql-1                Recreated   3.8s\n[+] Running 1/1\n \u283f Container ilc-mysql-1                Started     0.4s\n\n&gt; registry@1.0.0 seed /codebase\n&gt; knex --knexfile config/knexfile.ts seed:run\n\nRequiring external module ts-node/register\nWorking directory changed to /codebase/config\nWARNING: NODE_ENV value of 'production' did not match any deployment config file names.\nWARNING: See https://github.com/lorenwest/node-config/wiki/Strict-Mode\nRan 8 seed files\n</code></pre> </li> <li> <p>Open your browser and navigate to ILC or Registry UI:</p> <ul> <li><code>ILC</code>: http://localhost:8233/</li> <li><code>Registry UI</code>: http://localhost:4001/ (user: <code>root</code>, password: <code>pwd</code>)</li> </ul> </li> </ol> <p>Additional commands</p> <ul> <li>View logs: <code>docker compose logs -f --tail=10</code></li> <li>Shutdown local ILC: <code>docker compose down</code></li> </ul> <p>You can find more information about demo applications for this quick start in the namecheap/ilc-demo-apps repository.</p>"},{"location":"#architecture-overview","title":"Architecture overview","text":""},{"location":"#repository-structure","title":"Repository structure","text":"<p>The <code>namecheap/ilc</code> repository consists of the following parts:</p> <ul> <li><code>ilc</code>: code of the Isomorphic Layout Composer</li> <li><code>registry</code>: app that contains configuration that ILC uses: a list of micro-fragments, routes, etc.</li> </ul>"},{"location":"#further-reading","title":"Further reading","text":"<ul> <li>Overview</li> <li>Micro-frontend Types</li> <li>Step-By-Step lessons about apps development with ILC</li> <li>ILC to App interface</li> <li>ILC Registry</li> <li>Animation during reroute</li> <li>Global error handling</li> <li>Demo applications used in quick start</li> <li>SDK for ILC plugins development</li> <li>Compatibility with legacy UMD bundles</li> <li>Global API</li> <li>ILC transition hooks</li> <li>Multi-domains</li> <li>Public Path Problem</li> </ul>"},{"location":"#adapters","title":"\ud83d\udd0c Adapters","text":"<p>ILC relies on the adapters provided within the single-spa ecosystem to connect various frameworks. However, to ensure better integration with ILC, some of the original adapters were extended:</p> <ul> <li>React - ilc-adapter-react</li> <li>Vue.js - ilc-adapter-vue</li> </ul>"},{"location":"#notes","title":"Notes","text":""},{"location":"#portal-prefix","title":"<code>@portal/</code> prefix","text":"<p>ILC uses webpack (a static module bundler) to build each application for our micro-frontend approach. Webpack requires access to everything it needs to include in the bundle at build time. It means when an app imports a service (for example, planets import the fetchWithCache service), webpack tries to bundle the service into the planets bundle.</p> <p>The built-in way to prevent this behavior is webpack externals. This approach works well but to avoid adding a regex to each service ILC uses the <code>@portal</code> prefix to instruct both webpack and developers that the import is another micro-app/service/frontend.</p>"},{"location":"#code-splitting","title":"Code splitting","text":"<p>Code splitting is a complicated topic. In ILC, code splitting is even more complicated. The reason is that the webpack module format expects the loading of extra modules from the website root, which will always fail until a place from where to load extra modules is configured. In ILC, you can see an example of this approach in the demo people application.</p>"},{"location":"#sockets-timeout-to-fragments","title":"Sockets timeout to fragments","text":"<p>If you experience socket timeouts during requests to fragments, plese checkout this workaround https://github.com/namecheap/ilc/issues/444</p>"},{"location":"CONTRIBUTING/","title":"Contribution guide","text":"<p> Thank you for your interest in making ILC better. Your contributions are highly welcome.</p>"},{"location":"CONTRIBUTING/#install-and-setup-lde","title":"Install and setup LDE","text":"<ol> <li>Clone the namecheap/ilc repository.</li> <li>Run <code>npm install</code></li> <li>Run <code>npm start</code></li> <li>Open your browser and navigate to ILC or Registry UI:<ul> <li><code>ILC</code>: http://localhost:8233/</li> <li><code>Registry UI</code>: http://localhost:4001/</li> </ul> </li> </ol> <p>Dev mode for demo applications</p> <p>With the commands above, you start ILC with a set of demo applications running inside the Docker container. It is OK when you work with ILC. However, when you need to develop those applications alongside ILC, you should switch them into dev mode.</p> <p>To switch demo applications into dev mode:</p> <ol> <li>Clone the ilc-demo-apps</li> <li>Open a new Terminal instance (alongside the running one with ILC).</li> <li>Run <code>npm run start:no-apps</code></li> </ol>"},{"location":"CONTRIBUTING/#run-e2e-tests","title":"Run E2E tests","text":"<p>We use E2E tests to ensure that all ILC components work together properly.</p> <p>We use our Demo applications as a test platform for micro-frontends and also to ensure that backward compatibility is not broken.</p> <p>To run E2E tests:</p> <ol> <li>Build ILC and Registry: <code>npm run build</code></li> <li>Change your current directory to <code>./e2e</code></li> <li>Launch one of the following commands:<ul> <li>Default mode: <code>npm start</code></li> <li>Verbose mode: <code>npm run start:verbose</code></li> <li>Verbose mode with Browser UI visible: <code>npm run start:verbose:ui</code></li> </ul> </li> </ol>"},{"location":"CONTRIBUTING/#debug-mode","title":"Debug mode","text":"<p>ILC uses the debug package on the client-side to produce verbose logs for debug purposes.</p> <p>To enable it, type <code>localStorage.debug = 'ILC:*'</code> in your browser console.</p>"},{"location":"CONTRIBUTING/#watch-and-build-documentation","title":"Watch and build documentation","text":"<ol> <li>Build a Docker image: <code>docker build -t ilc-mkdocs - &lt; ./.mkdocs/Dockerfile</code></li> <li>Watch or build documentation:<ul> <li>Watch: <code>docker run --rm -it -p 8000:8000 -v ${PWD}:/docs ilc-mkdocs</code></li> <li>Build: <code>docker run --rm -v ${PWD}:/docs ilc-mkdocs build</code></li> </ul> </li> </ol>"},{"location":"LICENSE/","title":"Copyright 2020 Namecheap, Inc","text":"<p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"NOTICE/","title":"Notice","text":"<p>This product contains a modified version of Justin McMurdie's \"single-spa-portal-example\",  which can be obtained at:</p> <ul> <li>LICENSE: ISC</li> <li>HOMEPAGE: https://gitlab.com/TheMcMurder/single-spa-portal-example</li> </ul> <p>This product contains a modified version of Sam Stephenson's \"Prototype JavaScript Framework\",  which can be obtained at:</p> <ul> <li>LICENSE: Custom</li> <li>HOMEPAGE: https://github.com/prototypejs/prototype</li> </ul>"},{"location":"docs/animation_during_reroute/","title":"Animation during reroute","text":""},{"location":"docs/animation_during_reroute/#demo","title":"Demo","text":""},{"location":"docs/animation_during_reroute/#implementation-details","title":"Implementation details","text":"<ul> <li>Spinner appears only if the transition between routes takes more than 200ms.</li> <li>During the transition, ILC removes the original MSs and places fake-cloned nodes to DOM that don't have any JS mouse listeners. So it is recommended to use a backdrop for the spinner.</li> </ul>"},{"location":"docs/animation_during_reroute/#default-spinner-customization","title":"Default spinner customization","text":"<ul> <li>To set your own spinner, modify the <code>globalSpinner.customHTML</code> parameter in the ILC Registry settings page.</li> <li>To disable the spinner, disable the value of the <code>globalSpinner.enabled</code> parameter in the ILC Registry settings page.</li> </ul>"},{"location":"docs/app_wrappers/","title":"Wrapper for applications","text":""},{"location":"docs/app_wrappers/#overview","title":"Overview","text":"<p>This is an advanced feature of ILC. In most cases, you won't need it.</p> <p>Application wrapper is useful when you want to extract some bootstrap, loading or authorization functionality from different applications, and control them from a single place.</p> <p>For example, if you are building a store where product pages are developed by different teams. As a result, these pages will reside on different Micro Frontends. In this case, the business logic that checks whether the product has already been purchased by the customer can be extracted into a standalone application. This application would perform the check and render the corresponding UI for purchase, if necessary.</p>"},{"location":"docs/app_wrappers/#high-level-diagram","title":"High-level diagram","text":""},{"location":"docs/app_wrappers/#registry-configuration","title":"Registry configuration","text":"<p>To use this feature, you need to configure the ILC Registry as follows:</p> <ol> <li>For the registered App Wrapper application, set the <code>kind</code> property to <code>wrapper</code>.</li> <li>For the applications that you want to wrap with Wrapper, set <code>wrappedWith</code> property according to the name of the application, registered in the previous step.</li> </ol> <ul> <li>You cannot use applications with <code>kind = wrapper</code> in routes directly.</li> <li>If you need to wrap applications with SSR, make sure that the Wrapper (new or existing one) supports SSR as well. Otherwise, SSR support will be ignored for all wrapped applications.</li> </ul>"},{"location":"docs/app_wrappers/#build-app-wrapper","title":"Build App Wrapper","text":"<p>Essentially App Wrapper is a regular ILC application that receives extra property to allow the rendering of the target application  with additional properties when needed.</p> <p>Check the demo wrapper for reference implementation </p>"},{"location":"docs/app_wrappers/#client-side-api","title":"Client-side API","text":"<p>On the client-side, Wrapper App receives an additional <code>renderApp</code> property via ILC to App interface </p>"},{"location":"docs/app_wrappers/#server-side-api","title":"Server-side API","text":"<p>On the server-side, an application should use IlcAppWrapperSdk  from ilc-sdk instead of the regular IlcSdk  class</p> <p>It exposes an additional <code>forwardRequest</code> method that can be used to forward SSR request to the target application and render it  immediately on the client-side without executing App Wrapper's code during the initial CSR on page load.</p>"},{"location":"docs/develop_in_production/","title":"Develop in Production","text":"<p>ILC allows you to develop your micro frontends in the context of the production environment. It means that you can render your new application or change the version of the existing one directly at the production website.</p> <p>With this approach, you can see the final result faster without the need to mock other micro frontends inside your local development environment (LDE).</p>"},{"location":"docs/develop_in_production/#example","title":"Example","text":"<p>This example shows how to develop your application directly within the production deployment (production site).</p> <p>Imagine you want to replace the News application with a locally run version, using the production deployment as your target environment.</p> <p>To do this:</p> <ol> <li>Run the demo applications locally. Follow the instructions from the \"Development process\" section .</li> <li> <p>Expose your local applications:</p> <ul> <li> <p>If you don't have a \"white\" IP address, use ngrok  or a similar tool.</p> ngrok usage <ol> <li>Download &amp; install ngrok .</li> <li>Run <code>ngrok http 8239</code> (as the _News application_ uses the <code>8239</code> port).</li> <li>Use the exposed URL (it looks as follows: <code>http://c6960219.ngrok.io</code>).</li> </ol> </li> <li> <p>If you do have a \"white\" IP address, use the following URL: <code>http://your_public_ip:8239</code></p> </li> </ul> </li> <li> <p>Open the production deployment and add the following cookie:</p> <pre><code>const exposedUrl = 'http://c6960219.ngrok.io'; // or http://your_public_ip:8239\nconst overrideConfig = encodeURIComponent(\n    JSON.stringify({\n        apps: {\n            '@portal/news': {\n                spaBundle: exposedUrl + '/dist/single_spa.js',\n                cssBundle: exposedUrl + '/dist/common.css',\n                ssr: {\n                    src: exposedUrl + '/news/?fragment=1',\n                },\n                props: {\n                    publicPath: exposedUrl + '/dist/',\n                },\n            },\n        },\n    }),\n);\n\ndocument.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`;\n</code></pre> </li> <li> <p>Reload the production site several times.</p> <ul> <li>In the \"Network\" tab of the browser developer tools, check that some requests are served from the URL in <code>exposedUrl</code>.</li> </ul> </li> <li>Make a small change in your local News application. For example:<ol> <li>Go to the cloned <code>ilc-demo-apps</code> repository.</li> <li>Open the <code>/apps/news-ssr/src/components/Home.vue</code> file.</li> <li>Replace <code>&lt;h1&gt;Pick a news source&lt;/h1&gt;</code> with <code>&lt;h1&gt;Hello world&lt;/h1&gt;</code>.</li> <li>Open the production site and confirm the new heading appears.</li> </ol> </li> <li> <p>Check that SSR works correctly:</p> <ol> <li>Turn off Javascript in your browser </li> </ol> <p>After reloading the page, you should still see the correct \"Hello world\" heading.</p> </li> </ol>"},{"location":"docs/develop_in_production/#security-considerations","title":"Security considerations","text":"<p>The possibility of overriding ILC configuration for the browser using cookies introduces a risk of website defacement  attack via XSS .</p> <p>To mitigate this risk, ILC restricts (by default) all domains and real IP addresses specified for all links in configuration. Only private IPv4 addresses  are allowed.</p> <p>To allow specific origins, in the \"Settings\" page of the ILC Registry, set the <code>overrideConfigTrustedOrigins</code> property:</p> <ul> <li><code>default</code>: any origin is disallowed, except for private IPv4 addresses </li> <li><code>all</code>: trust any origins</li> <li><code>foo.com, bar.com</code>: trust <code>foo.com</code> and <code>bar.com</code> only (recommended)</li> </ul>"},{"location":"docs/develop_in_production/#create-your-ms","title":"Create your MS","text":"<ol> <li>Take the adapter  for your framework, wrap your application with it, and export lifecycle functions.</li> <li> <p>Turn off CORS for the development environment.</p> <p>Webpack config to disable CORS</p> <pre><code>devServer: {\n    headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n    },\n}\n</code></pre> </li> <li> <p>Wrap your MS bundle file with the following code:</p> <pre><code>'(function(define){\\n' + bundle_content + '\\n})((window.ILC &amp;&amp; window.ILC.define) || window.define);';\n</code></pre> <p>For Webpack, you can use wrapper-webpack-plugin </p> </li> <li> <p>Make sure your MS is publicly available - that is, hosted under 0.0.0.0 (default for Node http, and Express ) and exposed via your public IP address or with the help of specialized tools, like ngrok.</p> </li> <li> <p>Add <code>ILC-overrideConfig</code> cookie with the following configuration to production:</p> <pre><code>const overrideConfig = encodeURIComponent(\n    JSON.stringify({\n        apps: {\n            // rewrite the existing MS\n            '@portal/NAME1': {\n                spaBundle: 'http://10.1.150.85:2273/bundle.js', // url to bundle\n                ssr: {\n                    src: 'http://10.1.150.85:2273/', // url to ssr\n                },\n            },\n            // add new MS\n            '@portal/NAME2': {\n                spaBundle: 'http://10.1.150.85:9892/bundle.js', // url to bundle\n                ssr: {\n                    src: 'http://10.1.150.85:9891/', // url to ssr\n                    timeout: 1000,\n                },\n                kind: 'primary',\n            },\n        },\n        // add new MS slot to certain route\n        routes: [\n            {\n                routeId: 103,\n                route: '/example/',\n                next: false,\n                slots: {\n                    body: {\n                        appName: '@portal/NAME2',\n                        kind: null,\n                    },\n                },\n            },\n        ],\n    }),\n);\n\ndocument.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`;\n</code></pre> </li> <li> <p>Check that requests are not affected by the mixed content issue. If yes, you can turn off this check in your browser .</p> </li> <li>If you excluded some libraries (for example, via the <code>externals</code>  property of the webpack configuration), comment it when developing in production.</li> </ol>"},{"location":"docs/develop_in_production/#shared-libraries","title":"Shared libraries","text":"<p>Shared libraries are developed the same way as MSs. You only need to provide library name (without <code>@sharedLibrary/</code> prefix) and path to spa-bundle:</p> <pre><code>const overrideConfig = encodeURIComponent(\n    JSON.stringify({\n        sharedLibs: {\n            sampleLibrary: {\n                spaBundle: 'http://10.1.150.85:9001/bundle.js',\n            },\n        },\n    }),\n);\n\ndocument.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`;\n</code></pre>"},{"location":"docs/global_api/","title":"Global API","text":"<p>Global API documentation </p>"},{"location":"docs/global_error_handling/","title":"Global error handling","text":"<p>In the micro frontends architecture, handling errors (such as 5xx and 4xx) is a challenge because the common approach that is used for the monolithic frontend does not work here. This page describes how error handling is implemented in ILC.</p>"},{"location":"docs/global_error_handling/#app-types","title":"App types","text":"<ul> <li>Primary: an app that is responsible for the current route. Typically, this app renders the main consumable page content. You can have only one primary app for a particular route. During SSR, this app supplies HTTP response codes and headers to the client.</li> <li>Essential: an app that is treated as an essential part of a page. Typically, these are apps without which a page makes no sense to the user. For example, a website header.</li> <li>Regular: an app that provides extra functionality on a page. Typically, these apps do not impact the content, and users can consume a page even without these apps. For example, footer, ads, promo banners.</li> </ul>"},{"location":"docs/global_error_handling/#5xx-errors-unexpected-errors","title":"5xx errors (unexpected errors)","text":"<p>Handling of the unexpected errors varies between Server-side rendering (SSR) and Client-side rendering (CSR). It also depends on the type of app.</p> <p>There are no 5xx errors on the client-side. In ILC, this term is used for consistency and simplicity.</p>"},{"location":"docs/global_error_handling/#primary-apps","title":"Primary apps","text":"<ul> <li>SSR: all 5xx response codes trigger the 500 error page configured in ILC.</li> <li>CSR: any error caught by ILC errorHander, or errors during loading/mounting trigger the 500 error page configured in ILC.</li> </ul>"},{"location":"docs/global_error_handling/#essential-apps","title":"Essential apps","text":"<ul> <li> <p>SSR: all non-2xx response codes are treated as SSR error and the second rendering attempt will be done on the client-side.</p> <p>If you handle requests from SEO/SM bot, the 500 error page configured in ILC will be displayed.</p> </li> <li> <p>CSR: any error caught by ILC errorHander, or errors during loading/mounting trigger the 500 error page configured in ILC.</p> </li> </ul>"},{"location":"docs/global_error_handling/#regular","title":"Regular","text":"<ul> <li>SSR: all non-2xx response codes are treated as SSR error and the second rendering attempt will be done on the client-side.</li> <li>CSR: any error caught by ILC errorHander, or errors during loading/mounting are logged without any further action.</li> </ul>"},{"location":"docs/global_error_handling/#404-error-not-found","title":"404 error (Not found)","text":"<p>This is a common error in web applications that shows a message to the user when the requested resource was not found on the server.</p> <p>In ILC, this error can be caught in two different routing layers:</p> <ol> <li> <p>ILC Router: if there is no route configured in the Registry for the requested URL. This will trigger the special 404 route (Namecheap example ). This logic works seamlessly between SSR and CSR.</p> <p>404 error example</p> <p><code>/nosuchpath</code> URL was requested. Navigate to localhost:8233/nosuchpath  to see this error.</p> </li> <li> <p>App Router: (for primary apps only) if an app that is responsible for the page fails to find the requested resource by its ID even when the route is configured in the Registry. For example, when you're trying to open a page of a non-existing product.</p> <p>There are the following ways for an app to handle this case:</p> <ul> <li> <p>Fallback to global 404 page: (recommended approach) an app's content is abandoned and users will see the content of the special 404 route.</p> How to fallback to global 404 page on SSR/CSR <ul> <li>SSR: respond with 404 HTTP code.</li> <li>CSR: trigger <code>ilc:404</code> event on the window with the following parameter:<ul> <li><code>appId</code>: application ID that was passed by ILC to the app.</li> </ul> </li> </ul> </li> <li> <p>App-specific 404 page: use this approach only if you need to show a custom UI.</p> How to show an app-specific 404 page on SSR/CSR <ul> <li>SSR: respond with: 404 HTTP code and <code>X-ILC-Override: error-page-content</code> response header.</li> <li>CSR: render the custom UI that you need without triggering events.</li> </ul> </li> </ul> </li> </ol>"},{"location":"docs/global_error_handling/#401-unauthorized-and-403-forbidden-errors","title":"401 (Unauthorized) and 403 (Forbidden) errors","text":"<p>\u0421urrently, ILC has no specific logic for these error types. However, this may be reconsidered in the future.</p>"},{"location":"docs/i18n/","title":"Internationalization","text":"<p>With built-in internationalization support, you can use ILC to run micro frontends on websites that require a multilingual presence.</p> <p>Internationalization support is not comprehensive, though. You still need to provide i18n capabilities from the micro-frontends side.</p>"},{"location":"docs/i18n/#routing","title":"Routing","text":"<p>ILC uses a 2-tier routing model:</p> <ol> <li>ILC handles only global routing that determines what applications should be loaded at which URL.</li> <li>Micro frontend has its own routing that determines components to be rendered.</li> </ol>"},{"location":"docs/i18n/#1st-tier-ilc","title":"1st tier: ILC","text":"<p>ILC allows you to handle localized URLs globally - make sure that the <code>i18n.enabled</code> parameter is enabled in the ILC Registry.</p> <p>Currently, ILC supports two routing schemes:</p> <ul> <li>Prefixing all routes with locale except those of the default locale.</li> <li>Prefixing all routes with locale.</li> </ul> <p>In the Registry, you continue specifying all routes without locale information.</p>"},{"location":"docs/i18n/#2nd-tier-micro-frontend","title":"2nd tier: Micro frontend","text":"<p>When dealing with internationalization in micro frontends, it is recommended to separate concerns as you don't want to hardcode localized links in the source code of every micro frontend.</p> <p>Separation allows you to manage internationalization from a single place, and flexibly select localization patterns for your URLs.</p> <p>Localization implies two processes:</p> <ol> <li>Trimming actual <code>location.href</code> (to get locale) before passing the \"normalized\" URL to the application's router.</li> <li>Localization of the URL before rendering into the DOM.</li> </ol> <p>Both processes should be synchronized across all the applications and ILC. To do this, ILC provides <code>IlcIntl</code> class via App SDK that can be used at SSR and CSR.</p> <p>Example: React with SSR</p>"},{"location":"docs/i18n/#synchronized-language-currency-change","title":"Synchronized language / currency change","text":"<p>Let's say the customer wants to change the locale or currency on the website. Usually, it's impossible to render an updated  content immediately as localization files or updated prices should be loaded first.</p> <p>If only the locale/currency change event is triggered, and every micro frontend would handle this event separately, the customer would likely see the blinking on the frontend as a result of re-rendering of parts of UI at different moments in time.</p> <p>To prevent blinking, ILC uses prepare/execute pattern to synchronize re-rendering of all micro frontends.</p>"},{"location":"docs/i18n/#example","title":"Example","text":"<pre><code>class Root extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = { links: [] };\n\n        // This is a root React component, so it receives appSdk as property from ILC.\n        const lang = this.props.appSdk.intl.get().locale;\n        import(`./links/${lang}.json`).then(v =&gt; {\n            this.setState({links: v.default});\n        });\n    }\n\n    componentDidMount() {\n        this.props.appSdk.intl.onChange(\n            (e) =&gt; import(`./links/${e.locale}.json`), // Prepare all necessary data\n            (e, langModule) =&gt; { // Perform language change\n                this.setState({links: langModule.default});\n            }\n        );\n    }\n\n    changeLocale(locale, e) {\n        e.preventDefault();\n\n        this.props.appSdk.intl.set({ locale });\n    }\n\n    render() {\n        return (\n            &lt;div className='navbar-app'&gt;\n               {\n                   this.state.links.map((link) =&gt; {\n                       return (\n                           &lt;NavLink key={link.href}\n                                    to={this.props.appSdk.intl.localizeUrl(link.href)}&gt;\n                               {link.name}\n                           &lt;/NavLink&gt;\n                       )\n                   })\n               }\n\n               &lt;div className='lang-selector'&gt;\n                   &lt;NativeListener onClick={this.changeLocale.bind(this, 'en-US')}&gt;\n                       &lt;a href=\"#\" style={{color: 'white'}}&gt;EN&lt;/a&gt;\n                   &lt;/NativeListener&gt;\n                   /\n                   &lt;NativeListener onClick={this.changeLocale.bind(this, 'ua-UA')}&gt;\n                       &lt;a href=\"#\" style={{color: 'white'}}&gt;UA&lt;/a&gt;\n                   &lt;/NativeListener&gt;\n               &lt;/div&gt;\n           &lt;/div&gt;\n        );\n    }\n}\n</code></pre>"},{"location":"docs/ilc_app_interface/","title":"ILC to App interface","text":"<p>ILC to App interface documentation </p>"},{"location":"docs/microfrontend-types/","title":"Micro-frontend types","text":"<p>ILC has different categories of micro-frontends. You are free to decide where and how you use each of them. The table below gives you basic recommendations:</p> Topic Applications Parcels Global libraries SSR support Routing  (multiple routes) API Declarative API Imperative API Exports a public interface Renders UI  (may or may not render) Lifecycles ILC-managed lifecycles Custom managed lifecycles External module: no direct single-spa lifecycles When to use Core building block To embed part of one app into another Useful to share common logic, or create a service <p>Each ILC micro-frontend is an in-browser JavaScript module.</p>"},{"location":"docs/microfrontend-types/#applications","title":"Applications","text":"<p>Applications are registered in ILC Registry, and their lifecycle (when and where they should appear) is managed by ILC, based on the configuration of Routers and Templates.</p> <p>Applications act as the main building blocks for the website and can be rendered at the server-side to enhance page loading time and SEO/SMO metrics.</p>"},{"location":"docs/microfrontend-types/#parcels-in-applications","title":"Parcels in Applications","text":"<p>Applications can export Parcels to allow parts of their UI to be used in other apps.</p>"},{"location":"docs/microfrontend-types/#parcels","title":"Parcels","text":"<p>With Parcels, you can reuse parts of UI across applications when those applications are written in multiple frameworks. In other words, Parcels is an ILC-specific implementation of web components.</p>"},{"location":"docs/microfrontend-types/#use-case-example","title":"Use case example","text":""},{"location":"docs/microfrontend-types/#contacts-modal","title":"Contacts modal","text":"<p>Let's say, you have an <code>App1</code> that handles everything related to contacts (highly cohesive) but somewhere in <code>App2</code> you need to create a contact. To to this, you can use several techniques:</p> <ol> <li>If both are written in the same framework, you can export/import components.</li> <li>Re-implement creation of a contact (loss of cohesion).</li> <li>Use Parcels.</li> </ol> <p>Exporting a Parcel from <code>App1</code> that wraps the <code>createContact</code> modal component gives you the ability to share components and behavior across disparate frameworks without losing application cohesion. <code>App1</code> can export a modal as Parcel, and <code>App2</code> can import the Parcel and use it.</p>"},{"location":"docs/multi-domains/","title":"Multi-domains","text":"<p>ILC can handle requests from multiple domains so that you don't need to roll out individual instances of the ILC for every domain.</p>"},{"location":"docs/multi-domains/#add-a-new-domain-name","title":"Add a new domain name","text":"<ol> <li>Open the ILC Registry (http://localhost:4001/ by default).</li> <li>In the sidebar, choose Router domains. This page stores a list of all domains that are used within the ILC instance.</li> <li>In the top right corner, click + Create.</li> <li> <p>On the new page, in the Domain name field, type your domain name. For example, <code>example.com</code>.</p> <p>Provide only domain name, without a protocol</p> <p>ILC uses a strict comparison of a domain name, which means if you specify <code>example.com</code>, sub-domains like <code>foo.example.com</code> won't work. To include sub-domains, you need to specify <code>foo.example.com</code> or any other sub-domain that you are going to work with.</p> </li> <li> <p>In the Template of 500 error field, choose the default 500 template.</p> <p>To test this route immediately, navigate to the https://your_domain.com/_ilc/500 using your web browser.</p> <p>It is recommended to create a personal template to handle 500 errors for each of your domains.</p> </li> </ol>"},{"location":"docs/multi-domains/#add-error-handler","title":"Add error handler","text":"<ol> <li>In the sidebar, choose Routes.</li> <li> <p>In the top-left corner, enable the Show special toggle to see a list of special routes.</p> <p>The 404 route without a specified domain is used as a fallback for all domains and cannot be deleted.</p> <pre><code>You can use this route as a default for 404 errors for your domains.\n</code></pre> </li> <li> <p>In the top right corner, click + Create special route.</p> <p>In the general tab:</p> <ol> <li>In the Special role dropdown, select 404.</li> <li>In the Domain dropdown, select your domain.</li> </ol> </li> </ol>"},{"location":"docs/multi-domains/#add-a-new-route","title":"Add a new route","text":"<ol> <li> <p>In the top-left corner, disable the Show special toggle to see a list of simple routes.</p> <p>You can use the Domain dropdown list to the right of the Show special toggle to filter the list of domains that allows you to work only with routes for a specific domain name.</p> </li> <li> <p>In the top right corner, click + Create.</p> </li> <li> <p>On the new page, in the Domain field, type the domain name that you want to use for the new route.</p> <p>If you need to move already existing routes under a newly created domain, modify the Domain field in their preferences.</p> </li> <li> <p>Set other options according to your needs and click Save.</p> </li> <li>Navigate to the newly created route to check if everything works as expected.</li> </ol>"},{"location":"docs/multi-domains/#domain-specific-properties","title":"Domain-specific properties","text":"<p>Each Router Domain can have <code>props</code> and <code>ssrProps</code> configured. These properties are applied to all applications running on that domain.</p>"},{"location":"docs/multi-domains/#configure-domain-properties","title":"Configure domain properties","text":"<ol> <li>Open the ILC Registry and navigate to Router domains</li> <li>Select an existing domain or click + Create to add a new one</li> <li>Click the Domain Props tab</li> <li>Configure properties in the Client Props and SSR Props fields</li> <li>Click Save</li> </ol>"},{"location":"docs/multi-domains/#client-props","title":"Client Props","text":"<p>Properties that will be passed to application.</p> <p>Example:</p> <pre><code>{\n    \"apiUrl\": \"https://api.example.com\",\n    \"cdnUrl\": \"https://cdn.example.com\",\n    \"timeout\": 5000\n}\n</code></pre>"},{"location":"docs/multi-domains/#ssr-props","title":"SSR Props","text":"<p>Properties that will be added to main props at SSR request, allow to override certain values. These properties are never sent to the browser.</p> <p>Example:</p> <pre><code>{\n    \"internalApiUrl\": \"http://internal-api:3000\",\n    \"apiUrl\": \"http://internal-api:3000\"\n}\n</code></pre> <p>In this example, <code>apiUrl</code> from SSR Props will override the Client Props <code>apiUrl</code> during server-side rendering, but the browser will still receive the original Client Props value.</p>"},{"location":"docs/multi-domains/#properties-merging","title":"Properties merging","text":"<p>Properties from different levels are merged using deep merge. The merge order is:</p> <ol> <li>Application props (highest priority)</li> <li>Domain props</li> <li>Shared props (lowest priority)</li> </ol> <p>Example:</p> <p>Shared props:</p> <pre><code>{\n    \"apiUrl\": \"https://api.shared.com\",\n    \"timeout\": 3000\n}\n</code></pre> <p>Domain props for <code>example.com</code>:</p> <pre><code>{\n    \"apiUrl\": \"https://api.example.com\"\n}\n</code></pre> <p>App props:</p> <pre><code>{\n    \"timeout\": 5000\n}\n</code></pre> <p>Merged result for apps on <code>example.com</code>:</p> <pre><code>{\n    \"apiUrl\": \"https://api.example.com\",\n    \"timeout\": 5000\n}\n</code></pre>"},{"location":"docs/multi-domains/#canonical-domain","title":"Canonical domain","text":"<p>The canonical domain field specifies an alternative domain for canonical meta tags (<code>&lt;link rel=\"canonical\"&gt;</code>).</p>"},{"location":"docs/multi-domains/#configure-canonical-domain","title":"Configure canonical domain","text":"<ol> <li>Open the ILC Registry and navigate to Router domains</li> <li>Select a domain</li> <li>In the Canonical domain field, enter the domain name (without protocol, e.g., <code>www.example.com</code>)</li> <li>Click Save</li> </ol>"},{"location":"docs/multi-domains/#how-it-works","title":"How it works","text":"<p>When canonical domain is set, ILC generates canonical tags using the canonical domain instead of the request domain.</p> <p>Without canonical domain:</p> <pre><code>&lt;!-- Request: https://mirror.example.com/products --&gt;\n&lt;link rel=\"canonical\" href=\"https://mirror.example.com/products\" /&gt;\n</code></pre> <p>With canonical domain set to <code>www.example.com</code>:</p> <pre><code>&lt;!-- Request: https://mirror.example.com/products --&gt;\n&lt;link rel=\"canonical\" href=\"https://www.example.com/products\" /&gt;\n</code></pre>"},{"location":"docs/multi-domains/#interaction-with-route-metadata","title":"Interaction with route metadata","text":"<p>When both route <code>canonicalUrl</code> (in route metadata) and domain <code>canonicalDomain</code> are set, they combine:</p> <ul> <li>Request: <code>https://mirror.example.com/products/variant-123</code></li> <li>Route metadata: <code>{ \"canonicalUrl\": \"/products/main\" }</code></li> <li>Canonical domain: <code>www.example.com</code></li> <li>Result: <code>https://www.example.com/products/main</code></li> </ul> <p>See Route metadata canonicalUrl for more information.</p>"},{"location":"docs/multi-domains/#client-side-behavior","title":"Client-side behavior","text":"<p>ILC automatically updates canonical tags during client-side navigation.</p>"},{"location":"docs/multi-domains/#additional-information","title":"Additional information","text":"<ul> <li>ILC detects a domain from the request.host of Fastify and checks whether this hostname is listed in the Router domains.</li> <li>Each registered domain in the Router domains has its own set of routes that do not overlap.</li> <li>For routes, the domain is optional. If the request goes from the domain that is not listed in the Router domains, the routes for the request will stay unassigned.</li> </ul>"},{"location":"docs/overview/","title":"ILC setup overview","text":""},{"location":"docs/overview/#ilc-instance","title":"ILC instance","text":"<p>Production-grade ILC installation includes deployment of 3 Docker images:</p> <ol> <li>ILC</li> <li>ILC Registry</li> <li>MySQL database (version 5.7+).</li> </ol> <p>We recommend using semver Docker tags (such as <code>1.1.0</code>) to pin it to the exact version of the image.</p> <p>To get more information about exact configuration of the Docker images see docker-compose.yml </p>"},{"location":"docs/overview/#ilc-upgrade","title":"ILC upgrade","text":"<p>To upgrade ILC to a higher version, you need to replace running Docker images with a new version in the following order: Registry, ILC. In this way, you will always have a new version of ILC running alongside the up-to-date Registry.</p>"},{"location":"docs/overview/#environment-variables","title":"Environment variables","text":"<p>In ILC, most of the settings are configurable via Registry UI or API. There is also a set of system parameters that can only be configured via environment variables passed to the Docker container.</p> <p>Check the full list of these parameters in the following files:</p> <ul> <li>ILC container </li> <li>Registry container </li> </ul>"},{"location":"docs/overview/#authentication-credentials-configuration","title":"Authentication credentials configuration","text":"<p>Once you get ILC up and running, you must remove default access credentials and configure your own. Check the Registry: Authentication / Authorization document for more details.</p>"},{"location":"docs/overview/#high-availability-ha","title":"High availability (HA)","text":"<p>To deploy ILC in HA fashion, you need to keep at least two instances of both ILC and Registry and deploy MySQL in cluster mode (for example, via AWS RDS Multi-AZ).</p> <p>ILC uses aggressive caching of the data from the Registry, so it does not require a permanent connection to the Registry or a low latency response from the Registry.</p>"},{"location":"docs/overview/#backup-and-restore","title":"Backup and restore","text":"<p>As ILC stores all user data in the Registry DB, you can use regular MySQL backup/restore practices.</p>"},{"location":"docs/overview/#performance-analytics-with-newrelic","title":"Performance analytics with NewRelic","text":"<p>ILC supports integration with NewRelic APM and NewRelic Browser. It can also send custom metric to NewRelic Insights.</p> <p>To enable the integration, you need to pass your NewRelic license key in <code>NR_LICENSE_KEY</code> environmental variable to ILC and Registry containers.</p> <p>If you have the NewRelic Browser enabled, you can wrap JavaScript code that NewRelic generates using the <code>NR_CUSTOM_CLIENT_JS_WRAPPER</code> environmental variable. This approach may be useful for compliance with GDPR customer settings.</p> <p>For example:</p> <pre><code>&lt;script type=\"text/javascript\"&gt;(function mygdprWrapper(){ %CONTENT% })()&lt;/script&gt;`\n</code></pre> <p>Custom metrics sent to Insights:</p> <ul> <li>PageAction with Action Name <code>routeChange</code>. It contains the duration of the reroute in miliseconds.</li> </ul>"},{"location":"docs/parcels/","title":"Parcels","text":""},{"location":"docs/parcels/#overview","title":"Overview","text":"<p>ILC / single-spa Parcel is a framework, and language-agnostic component that acts as a reusable piece of functionality meant to be mounted manually by an application via a manual function call (not by ILC). You can choose any language for your Parcel, and the resulting Parcel can be as large as an application or as small as a component. The only requirement is that a Parcel should export the correct lifecycle events.</p> <p>In ILC, your website can contain multiple applications and each application may also export Parcels.</p> <p>You can export Parcels from the application's bundle only.</p> <p>If you are using only one framework, it is recommended to use native framework components (for example, React, Vue, and Angular components) over Parcels, as Parcels act as an intermediary layer which may complicate components' interoperation.</p>"},{"location":"docs/parcels/#demo-and-examples","title":"Demo and examples","text":"<p>Make sure your local ILC instance is running</p>"},{"location":"docs/parcels/#react","title":"React","text":"<p>Go to http://localhost:8233/people and click <code>Open</code> in the main window. This action will render Vue.js application inside React application.</p>"},{"location":"docs/parcels/#parcel-export","title":"Parcel export","text":"<p>Parcel export</p> Application bundle entrypoint<code>./person.parcel.js</code> <pre><code>import ilcAdapterReact, { ParcelLifecycleFnProps } from 'ilc-adapter-react';\nimport Root from './root.component';\n\nexport default {\n    ...ilcAdapterReact&lt;AppLifecycleFnProps&gt;({\n        rootComponent: Root,\n    }),\n    parcels: {\n        person: ilcAdapterReact&lt;ParcelLifecycleFnProps&gt;({\n            loadRootComponent: () =&gt; import('./person.parcel.js').then(property('default')),\n        }),\n    },\n};\n</code></pre> <pre><code>import React from 'react';\nimport { ParcelLifecycleFnProps } from 'ilc-adapter-react';\n\nexport default (props: ParcelLifecycleFnProps) =&gt; {\n    return &lt;div&gt;Hello world&lt;/div&gt;;\n};\n</code></pre> <p> Link to the full code</p>"},{"location":"docs/parcels/#parcel-usage","title":"Parcel usage","text":"<p>Parcel usage</p> <pre><code>import Parcel from 'ilc-adapter-react/parcel';\n\nexport default () =&gt; (\n    &lt;div&gt;\n        &lt;Parcel\n            loadingConfig={{ appName: '@portal/planets', parcelName: 'planet' }}\n            wrapWith=\"div\"\n            customParam1=\"testProp\"\n        /&gt;\n    &lt;/div&gt;\n);\n</code></pre> <p> Link to the full code</p>"},{"location":"docs/parcels/#vuejs","title":"Vue.js","text":"<p>Go to http://localhost:8233/planets and click <code>Open</code> in the main window. This action will render React.js application inside Vue.js application.</p>"},{"location":"docs/parcels/#parcel-export_1","title":"Parcel export","text":"<p>Parcel export</p> Application bundle entrypoint <pre><code>import Vue from 'vue';\nimport App from './App.vue';\nimport PlanetParcel from './planet-parcel.vue';\nimport singleSpaVue from 'ilc-adapter-vue';\n\nexport default {\n    ...singleSpaVue({\n        Vue,\n        appOptions: {\n            render(h) {\n                return h(App, {\n                    props: {\n                        mountParcel: this.mountParcel,\n                    }\n                })\n            },\n        }\n    }),\n    parcels: {\n        planet: singleSpaVue({\n            Vue,\n            appOptions: {\n                render(h) {\n                    return h(PlanetParcel, {\n                        props: {\n                            id: this.id,\n                            mountParcel: this.mountParcel,\n                        }\n                    })\n                },\n            }\n        })\n    }\n};\n</code></pre> <p> Link to the full code</p>"},{"location":"docs/parcels/#parcel-usage_1","title":"Parcel usage","text":"<p>Parcel usage</p> <pre><code>import Parcel from 'ilc-adapter-react/parcel';\n\nexport default () =&gt; (\n    &lt;div&gt;\n        &lt;Parcel\n            loadingConfig={{ appName: '@portal/planets', parcelName: 'planet' }}\n            wrapWith=\"div\"\n            customParam1=\"testProp\"\n        /&gt;\n    &lt;/div&gt;\n);\n</code></pre> <p> Link to the full code</p> <p>Component that uses Parcel</p> <pre><code>&lt;template&gt;\n&lt;div&gt;\n    &lt;Parcel\n        :config=\"parcelConfig()\"\n        :mountParcel=\"mountParcel\"\n        :parcelProps=\"getParcelProps()\"\n    /&gt;\n&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport Parcel from 'single-spa-vue/dist/esm/parcel';\n\nexport default {\ncomponents: {\n    Parcel,\n},\ndata() {\n    return {\n    parcelConfig: () =&gt; window.ILC.importParcelFromApp('@portal/people', 'person')\n    }\n},\nmethods: {\n    getParcelProps() {\n    return {\n        id: 1,\n    }\n    },\n},\ninject: ['mountParcel'],\n}\n&lt;/script&gt;\n</code></pre> <p>Application's root component</p> <p>ILC uses <code>provide()</code>/<code>inject</code> to pass <code>mountParcel</code> function to all child components:</p> <pre><code>&lt;script&gt;\nexport default {\n    props: ['mountParcel'],\n    provide() {\n        return {\n            mountParcel: this.mountParcel\n        }\n    }\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"docs/parcels/#api","title":"API","text":"<p>ILC Parcels are 95% compatible with single-spa API  but there are the following features from our side:</p> <ul> <li>Additional lifecycle function properties  that allow you to receive application properties from Registry, and I18n configuration via ParcelSDK </li> <li>ILC-favoured <code>mountRootParcel</code> </li> <li><code>ILC.importParcelFromApp</code> - a convenient way to import Parcel from an application imperatively </li> </ul>"},{"location":"docs/registry/","title":"ILC Registry","text":"<p>The Registry provides UI and REST API to publish, update, and retrieve micro frontends, templates, and routes configuration.</p> <p>The Registry is available at the <code>4001</code> port by default (use http://127.0.0.1:4001 for a locally launched ILC).</p>"},{"location":"docs/registry/#authentication-and-authorization","title":"Authentication and authorization","text":"<p>Currently, Registry supports authentication only. All authenticated entities will receive a full set of permissions.</p> <p>The following authentication providers are supported:</p> <ul> <li>OpenID Connect. Turned off by default.</li> <li>Locally configured login/password. Default credentials: <code>root</code> / <code>pwd</code>.</li> <li>Locally configured Bearer token for API machine-to-machine access. Default credentials: <code>Bearer cm9vdF9hcGlfdG9rZW4=:dG9rZW5fc2VjcmV0</code> or <code>Bearer root_api_token:token_secret</code> after base64 decoding.</li> </ul> <p>You can change default credentials via Registry UI, in the <code>Auth entities</code> page, or via API.</p>"},{"location":"docs/registry/#openid-configuration","title":"OpenID Configuration","text":"<p>To configure OpenID:</p> <ol> <li>Open Registry UI.</li> <li>Go to the Settings page.</li> <li>Find keys that start with <code>auth.openid.*</code>.</li> </ol> <p>Sample configuration (values are JSON-encoded):</p> key value <code>baseUrl</code> <code>\"https://ilc-registry.example.com/\"</code> <code>auth.openid.enabled</code> <code>true</code> <code>auth.openid.discoveryUrl</code> <code>\"https://adfs.example.com/adfs/\"</code> <code>auth.openid.clientId</code> <code>\"ba34c345-e543-6554-b0be-3e1097ddd32d\"</code> <code>auth.openid.clientSecret</code> <code>\"XXXXXX\"</code> <p>OpenID Connect returnURL should be specified at provider in the following format: <code>{baseUrl}/auth/openid/return</code></p>"},{"location":"docs/registry/#user-interface","title":"User Interface","text":""},{"location":"docs/registry/#api","title":"API","text":"<p>Currently there is no documentation for API endpoints. As an alternative, you can use Network tab in your browser's developer tools to see how UI communicates with API. You can also explore code starting from the <code>/registry/server/app.ts</code> file.</p>"},{"location":"docs/registry/#updating-jscss-urls-during-micro-frontends-deployment","title":"Updating JS/CSS URLs during micro frontends deployment","text":"<p>It is a common practice to store JS/CSS files of the micro frontend apps at CDN using unique URLs. For example, <code>https://site.com/layoutfragments-ui/app.80de7d4e36eae32662d2.js</code>.</p> <p>By following this this approach, you need to update links to the JS/CSS bundles in the Registry after each deployment.</p> <p>To do this, there are the following options (at least):</p> <ul> <li>Manually via UI (not recommended)</li> <li>Using Registry API (see API section above)</li> <li>Using App Assets discovery mechanism</li> </ul> <p>When registering micro frontend in the ILC Registry, it is possible to set a file for the \"Assets discovery url\" that will be periodically fetched by the Registry. The idea is that this file will contain actual references to JS/CSS bundles and be updated on CDN right after every deployment.</p> <p><code>https://site.com/layoutfragments-ui/assets-discovery.json</code></p> <p><code>json     {       \"spaBundle\": \"https://site.com/layoutfragments-ui/app.80de7d4e36eae32662d2.js\",       \"cssBundle\": \"./app.81340a47f3122508fd76.css\", // It is possible to use relative links that will be resolved against the manifest URL       \"dependencies\": {         \"react\": \"https://unpkg.com/react@16.13.1/umd/react.production.min.js\"       }     }</code></p>"},{"location":"docs/registry/#batch-atomic-config-update","title":"Batch Atomic Config Update","text":"<p>Atomic config updates can be performed using the <code>PUT /api/v1/config</code> endpoint. Resource data will be replaced completely (except few keys, such as <code>adminNotes</code> or <code>l10nManifest</code>). If the <code>namespace</code> key is specified in app or route, all resources that are not listed in the config payload with same namespace value will be automatically removed. Below is an example of a JSON request body:</p> <pre><code>{\n    \"apps\": [\n        {\n            \"name\": \"Application name\",\n            \"assetsDiscoveryUrl\": \"Url to fetch assets location\",\n            \"ssr\": {\n                \"src\": \"SSR url\",\n                \"timeout\": 3000\n            },\n            \"props\": {\n                \"key\": \"value\"\n            },\n            \"ssrProps\": {\n                \"key\": \"value\"\n            },\n            \"configSelector\": [\"sharedPropertiesKey\"],\n            \"kind\": \"primary\",\n            \"discoveryMetadata\": {},\n            \"namespace\": \"Application namespace, used to as a part of unique identifier (application name and namespace). All apps, that are not listed in the config payload under this namespace will be automatically removed.\"\n        }\n    ],\n    \"routes\": [\n        {\n            \"route\": \"/route/*\",\n            \"slots\": {\n                \"body\": {\n                    \"appName\": \"Application name\",\n                    \"props\": {\n                        \"key\": \"value\"\n                    }\n                }\n            },\n            \"namespace\": \"Route namespace, used to as a part of unique identifier (route value, domainId and namespace). All routes, that are not listed in the config payload under this namespace will be automatically removed.\"\n        }\n    ],\n    \"sharedLibs\": [\n        {\n            \"name\": \"Library name\",\n            \"assetsDiscoveryUrl\": \"Url to fetch assets location\"\n        }\n    ]\n}\n</code></pre> <p>There might be cases where you want to test your configuration before deploying services or simply perform a dry run of the config update action. To do this, call the <code>POST /api/v1/config/validate</code> endpoint with the same request body as the config update. This API returns a response in the following format:</p> <pre><code>{\n    \"valid\": false,\n    \"details\": \"Error details\"\n}\n</code></pre> <p>Note, that this API is available only if using PostgreSQL database.</p>"},{"location":"docs/registry/#application-properties","title":"Application properties","text":"<p>ILC provides a multi-level properties system. Properties can be defined at application, domain, and shared levels.</p>"},{"location":"docs/registry/#property-levels","title":"Property levels","text":"Level Scope Configuration Location Application props Specific application Apps \u2192 Props Domain props Apps on specific domain Router Domains \u2192 Domain Props Shared props Multiple apps Shared Props"},{"location":"docs/registry/#property-types","title":"Property types","text":"<p><code>props</code> - Properties that will be passed to application.</p> <p><code>ssrProps</code> - Properties that will be added to main props at SSR request, allow to override certain values. Never sent to the browser.</p>"},{"location":"docs/registry/#merging-behavior","title":"Merging behavior","text":"<p>Properties are merged using deep merge with the following priority:</p> <ol> <li>Application props (highest priority)</li> <li>Domain props</li> <li>Shared props (lowest priority)</li> </ol> <p>Example:</p> <pre><code>// Shared props\n{ \"apiUrl\": \"https://api.shared.com\", \"timeout\": 3000 }\n\n// Domain props\n{ \"apiUrl\": \"https://api.domain.com\" }\n\n// App props\n{ \"timeout\": 5000 }\n\n// Merged result\n{ \"apiUrl\": \"https://api.domain.com\", \"timeout\": 5000 }\n</code></pre>"},{"location":"docs/registry/#shared-properties","title":"Shared properties","text":"<p>Applications reference shared properties via the <code>configSelector</code> field.</p> <p>Example application configuration:</p> <pre><code>{\n    \"name\": \"myApp\",\n    \"configSelector\": [\"commonConfig\"],\n    \"props\": {\n        \"appSpecific\": true\n    }\n}\n</code></pre>"},{"location":"docs/registry/#domain-properties","title":"Domain properties","text":"<p>See Multi-domains documentation for information about configuring domain-specific properties.</p>"},{"location":"docs/transition_hooks/","title":"ILC transition hooks","text":"<p>ILC allows you to check a route before navigating to it.</p> <p>To handle it, you need to create an ILC transition hooks plugin using the ILC plugins SDK  to cover cases that depend on accessing any route.</p> <p></p>"},{"location":"docs/transition_hooks/#ilc-transition-hooks-plugin","title":"ILC transition hooks plugin","text":"<p>ILC transition hooks plugin should follow a specific interface  that the ILC plugins SDK  provides for this plugin.</p> <p>ILC gets transition hooks from the plugin and calls them before navigating a route. It works for both SSR and CSR.</p> <p>There are the following options to handle the navigation event: 1. Stop navigation and use your custom behavior such as authentication form as an example to navigate whenever you need (CSR). 2. Redirect to a new location (CSR, SSR). 3. Continue navigation (CSR, SSR).</p> <p>From ILC, every transition hook receives route information (URL, route meta information that a route has in the ILC registry).</p> <p>The provided route information allows you to handle only the routes that you need. For example, in the ILC Registry, you can mark some routes as protected in the Metadata field, and handle navigation to those marked routes as required.</p> <p></p> <p>Example of the default ILC transition hooks plugin</p> <p>Check an example of the default ILC transition hooks plugin  in ILC plugins SDK </p>"},{"location":"docs/transition_hooks/#server-side-api","title":"Server-side API","text":"<p>Transition hooks are asynchronous on the server-side.</p> <p>From ILC, every hook receives route information, ILC logger, and the current request on the server-side.</p> <p>You have to use the ILC logger when you need to log inside of your hook. ILC has its own log interface on the server-side, so every application or plugin should follow it.</p>"},{"location":"docs/transition_hooks/#client-side-api","title":"Client-side API","text":"<p>Transition hooks are synchronous on the client side. ILC calls them on each History change event.</p> <p>From ILC, every hook receives route information and navigate method on the client-side.</p> <p>Whenever you need to navigate to a route from your hook, you need to use that provided navigate method to keep the ILC SPA routing mechanism safe.</p>"},{"location":"docs/transition_hooks/#demo","title":"Demo","text":"<p>Run your ILC locally and go to localhost:8233/hooks  to see how hooks work.</p>"},{"location":"docs/umd_bundles_compatibility/","title":"Compatibility with legacy UMD bundles","text":"<p>When adding ILC to the legacy website, you may have an issue when the code that is loaded via regular <code>&lt;script&gt;</code> tags works incorrectly. This happens when you load external libraries packed as UMD bundles.</p> <p>By default, ILC exposes the <code>window.define</code> variable that forces all UMD bundles to be registered within ILC (via System.js). While this approach is convenient for the new projects, it may break things for the legacy ones.  The reason is that without ILC and System.js running, the content of the UMD bundle is to be registered as a <code>window</code> variable.</p> <p>To fix the issue, you need to enable the <code>amdDefineCompatibilityMode=true</code> on the Settings page in the ILC Registry. It removes the <code>window.define</code> variable, so all your libraries will use <code>window.ILC.define</code> instead.</p> <p>If you use webpack, you can force the usage of <code>window.ILC.define</code> when building applications for ILC:</p> <pre><code>const ilcWebpackPluginsFactory = require('ilc-sdk').WebpackPluginsFactory;\n\nmodule.exports = {\n    entry: 'src/app.js',\n    output: {\n        filename: 'app.js',\n        libraryTarget: 'amd',\n    },\n    module: { /* ... */ },\n    plugins: ilcWebpackPluginsFactory().client,\n};\n</code></pre>"},{"location":"docs/how-to-guides/","title":"How to create applications with ILC","text":""},{"location":"docs/how-to-guides/#react","title":"React","text":"<ul> <li>Lesson 1</li> <li>Lesson 2</li> <li>Lesson 3</li> <li>Lesson 4</li> </ul>"},{"location":"docs/how-to-guides/react/lesson1/","title":"React application + ILC. Lesson 1","text":"<p>Hello everyone!</p> <p>In this document, you will learn how to create a simple isomorphic React application and run it with ILC in a few minutes.</p> <p>Let's get started \ud83d\ude80</p>"},{"location":"docs/how-to-guides/react/lesson1/#get-your-react-application-ready","title":"Get your React application ready","text":"<p>To build a new micro-frontend, you need a React application with SSR support.</p> <p>To make things easier, you can clone the application that we've prepared for you, or start with this application running in the cloud. For the sake of simplicity, it is recommended to use the cloud version.</p> <p>Don't forget to play the tic-tac-toe game before we actually get started \ud83d\ude0e</p>"},{"location":"docs/how-to-guides/react/lesson1/#adapt-the-application-to-ilc","title":"Adapt the application to ILC","text":"<p>To make the application work correctly with ILC, you need to make it compliant with the ILC to App interface.</p> <p>To do this, go through the source code and resolve all the <code>//TODO:</code> comments that were placed there for you (Hint: there are 4 of them \ud83d\ude09)</p> <p>Once you're done, restart the application and navigate to the <code>/microfrontend</code> route. You should get a <code>200 OK</code> response code and SSR markup as a result.</p> <p>If you are facing troubles during this step, feel free to switch to the <code>step_1-ILC_integration</code> branch which has all the required changes already made for you.</p>"},{"location":"docs/how-to-guides/react/lesson1/#configure-ilc-to-handle-the-application","title":"Configure ILC to handle the application","text":"<p>Make sure your local ILC instance is running</p> <p>To configure your micro-frontend:</p> <ol> <li> <p>Determine your <code>publicPath</code> and <code>ssrPath</code>:</p> <ol> <li> <p>For <code>codesandbox.io</code>:</p> <ul> <li><code>publicPath</code>: <code>https://xxxxx.sse.codesandbox.io/public/</code></li> <li><code>ssrPath</code>: <code>https://xxxxx.sse.codesandbox.io/microfrontend</code></li> </ul> <p>where <code>xxxxx</code> are random alphanumeric characters. Check the address bar of your virtual browser.</p> </li> <li> <p>For local instance:</p> <ul> <li><code>publicPath</code>: <code>http://127.0.0.1:5000/public/</code></li> <li><code>ssrPath</code>: <code>http://&lt;white_ip_address&gt;:5000/microfrontend</code></li> </ul> <p>where <code>&lt;white_ip_address&gt;</code> is the real IP address of your machine or the one generated via services like ngrok.</p> <p>To work with ILC via <code>ngrok</code>, you need to create a free account at ngrok.com and obtain an <code>authtoken</code>.</p> </li> </ol> Examples of <code>publicPath</code> and <code>ssrPath</code> codesandbox.iolocal instance <ul> <li><code>publicPath</code>: <code>https://1a2b3.sse.codesandbox.io/public/</code></li> <li><code>ssrPath</code>: <code>https://1a2b3.sse.codesandbox.io/microfrontend</code></li> </ul> <ul> <li><code>publicPath</code>: <code>http://127.0.0.1:5000/public/</code></li> <li><code>ssrPath</code>: <code>http://123.456.78.90:5000/microfrontend</code></li> </ul> <p>If you're using <code>ngrok</code>, assuming it is launched via <code>ngrok http 5000</code></p> <ul> <li><code>publicPath</code>: <code>http://127.0.0.1:5000/public/</code></li> <li><code>ssrPath</code>: <code>https://12ab34cd56e7.ngrok-free.app/microfrontend</code></li> </ul> </li> <li> <p>Update the ILC configuration:</p> <ol> <li>Navigate to the http://localhost:8233/nosuchpath</li> <li> <p>Execute the code below in the browser console (Developer tools):</p> <pre><code>var publicPath = 'https://xxxxx.sse.codesandbox.io/public/';\nvar ssrPath = 'https://xxxxx.sse.codesandbox.io/microfrontend';\nvar overrideConfig = encodeURIComponent(JSON.stringify({\napps: {\n    '@portal/myapp': {\n    spaBundle: publicPath + 'client.js',\n    cssBundle: publicPath + 'style.css',\n    ssr: {\n        src: ssrPath,\n        timeout: 10000,\n    },\n    props: { publicPath },\n    kind: 'primary',\n    },\n},\nroutes: [{\n    routeId: 555,\n    route: '/nosuchpath',\n    slots: {\n    body: {\n        appName: '@portal/myapp'\n    }\n    }\n}]\n}));\n\ndocument.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`\n</code></pre> </li> </ol> </li> <li> <p>Refresh the page after code execution.</p> <p>You should see your application running inside the public ILC demo website.</p> <p></p> <p>If you can't - check both <code>publicPath</code> and <code>ssrPath</code>, and ensure that links to JS/CSS resources are correct.</p> </li> </ol> <p>Congratulations! \ud83c\udf89 Now you know how to integrate your new React application with ILC.</p>"},{"location":"docs/how-to-guides/react/lesson2/","title":"React application + ILC. Lesson 2","text":"<p>Hello everyone!</p> <p>In the first tutorial, you created a React application from scratch and integrated it into a \"production\" instance of ILC on-the-fly.</p> <p>In this tutorial, you will get familiar with the routing and turn your application (from the previous tutorial) into a micro-frontend that works with ILC.</p> <p>Let's get started \ud83d\ude80</p>"},{"location":"docs/how-to-guides/react/lesson2/#overview","title":"Overview","text":"<p>Routing is one of the hard questions to solve when applying the micro-frontend architecture. The problem is that you no longer have a single application that handles all the route transitions. Instead, you have multiple applications working simultaneously on the web page, and you need to know what application should be active at one time or another for the current URL.</p> <p>ILC uses two-tiered routing to solve this problem.</p> <p></p> <p>In this example, when the user opens a URL (<code>/news/latest</code>), this URL matches the route configured in ILC (<code>/news/*</code>). The route contains information about the applications that should be loaded on the page and the props they need to receive. When ILC loads and mounts the application to its DOM node container, it also passes the <code>basePath</code> property to instruct the application on what routing it should use.</p> <p>You can find more information about routing in the Introduction page.</p>"},{"location":"docs/how-to-guides/react/lesson2/#get-your-react-application-ready","title":"Get your React application ready","text":"<p>For this tutorial, you need the React application with the following internal routes: Home, Tic-Tac-Toe, and Snake games.</p> <p>To make things easier, you can clone the sample that we've prepared for you (and then checkout to the <code>step_2-Router</code> branch), or start with this application running in the cloud. For the sake of simplicity, it is recommended to use the cloud version.</p> <p>Don't forget to play around with links, games, and check the diff with the <code>master</code> branch before we actually get started \ud83d\ude0e</p> <p></p>"},{"location":"docs/how-to-guides/react/lesson2/#adapt-the-application-to-ilc","title":"Adapt the application to ILC","text":"<p>To make the application work correctly with ILC, you need to make it compliant with the ILC to App interface.</p> <p>To do this, go through the source code and resolve all the <code>//TODO:</code> comments that were placed there for you (Hint: there are still 4 of them \ud83d\ude09)</p> <p>Once you're done, restart the application and navigate to the <code>/microfrontend</code> route. You should get a <code>200 OK</code> response code and SSR markup as a result.</p> <p>If you are facing troubles during this step, feel free to switch to the <code>step_2-Router_ILC_integrated</code> branch which has all the required changes already made for you.</p>"},{"location":"docs/how-to-guides/react/lesson2/#configure-ilc-to-handle-the-application","title":"Configure ILC to handle the application","text":"<p>Make sure your local ILC instance is running</p> <p>To configure your micro-frontend:</p> <ol> <li> <p>Determine your <code>publicPath</code> and <code>ssrPath</code>:</p> <ol> <li> <p>For <code>codesandbox.io</code>:</p> <ul> <li><code>publicPath</code>: <code>https://xxxxx.sse.codesandbox.io/public/</code></li> <li><code>ssrPath</code>: <code>https://xxxxx.sse.codesandbox.io/microfrontend</code></li> </ul> <p>where <code>xxxxx</code> are random alphanumeric characters. Check the address bar of your virtual browser.</p> </li> <li> <p>For local instance:</p> <ul> <li><code>publicPath</code>: <code>http://127.0.0.1:5000/public/</code></li> <li><code>ssrPath</code>: <code>http://&lt;white_ip_address&gt;:5000/microfrontend</code></li> </ul> <p>where <code>&lt;white_ip_address&gt;</code> is the real IP address of your machine or the one generated via services like ngrok.</p> <p>To work with ILC via <code>ngrok</code>, you need to create a free account at ngrok.com and obtain an <code>authtoken</code>.</p> </li> </ol> Examples of <code>publicPath</code> and <code>ssrPath</code> codesandbox.iolocal instance <ul> <li><code>publicPath</code>: <code>https://1a2b3.sse.codesandbox.io/public/</code></li> <li><code>ssrPath</code>: <code>https://1a2b3.sse.codesandbox.io/microfrontend</code></li> </ul> <ul> <li><code>publicPath</code>: <code>http://127.0.0.1:5000/public/</code></li> <li><code>ssrPath</code>: <code>http://123.456.78.90:5000/microfrontend</code></li> </ul> <p>If you're using <code>ngrok</code>, assuming it is launched via <code>ngrok http 5000</code></p> <ul> <li><code>publicPath</code>: <code>http://127.0.0.1:5000/public/</code></li> <li><code>ssrPath</code>: <code>https://12ab34cd56e7.ngrok-free.app/microfrontend</code></li> </ul> </li> <li> <p>Update the ILC configuration:</p> <ol> <li>Navigate to the http://localhost:8233/nosuchpath</li> <li> <p>Execute the code below in the browser console (Developer tools):</p> <pre><code>var publicPath = 'https://xxxxx.sse.codesandbox.io/public/';\nvar ssrPath = 'https://xxxxx.sse.codesandbox.io/microfrontend';\n\nvar overrideConfig = encodeURIComponent(JSON.stringify({\n    apps: {\n        '@portal/myapp': {\n            spaBundle: publicPath + 'client.js',\n            cssBundle: publicPath + 'style.css',\n            ssr: {\n                src: ssrPath,\n                timeout: 10000,\n            },\n            props: { publicPath },\n            kind: 'primary',\n        },\n    },\n    routes: [{\n        routeId: 555,\n        route: '/nosuchpath/*',\n        slots: {\n            body: {\n                appName: '@portal/myapp'\n            }\n        }\n    }]\n}));\n\ndocument.cookie = `ILC-overrideConfig=${overrideConfig}; path=/;`\n</code></pre> </li> </ol> </li> <li> <p>Refresh the page after code execution.</p> <p>You should see your application running inside the public ILC demo website.</p> <p></p> <p>If you can't - check both <code>publicPath</code> and <code>ssrPath</code>, and ensure that links to JS/CSS resources are correct.</p> </li> </ol>"},{"location":"docs/how-to-guides/react/lesson2/#explore-the-results","title":"Explore the results","text":"<p>When checking how your application works on the public ILC demo website, pay attention to the <code>Demo News app</code> link. As you can see from the source code (or via the Developer Tools), it is a regular link - <code>&lt;a&gt;</code> tag, but it doesn't trigger a page reload and loads another application smoothly. It is one of the ILC's cool features that help make ILC work with legacy monolithic applications.</p> <p>You can also try disabling JavaScript and go through the links again. You should admit that all the pages look the same as before (except that you can't play games now).</p>"},{"location":"docs/how-to-guides/react/lesson2/#summary","title":"Summary","text":"<p>Congratulations! \ud83c\udf89 In just half an hour, you turned a simple React router-based application into a micro-frontend. We hope it was nice and smooth for you.</p>"},{"location":"docs/how-to-guides/react/lesson3/","title":"Step by step apps creation with ILC, React, Lesson 3","text":"<p>Hi folks! This document will teach you how to add state handling to the app we've created in previous lesson.</p>"},{"location":"docs/how-to-guides/react/lesson3/#tbd","title":"TBD","text":""},{"location":"docs/how-to-guides/react/lesson4/","title":"Step by step apps creation with ILC, React, Lesson 4","text":"<p>Hi folks! This document will teach you how to add title &amp; meta tags handling with the help of  react-helmet to the app we've created in previous lesson.</p>"},{"location":"docs/how-to-guides/react/lesson4/#tbd","title":"TBD","text":""},{"location":"docs/routing/introduction/","title":"Introduction","text":"<p>Most JavaScript frameworks come with a dedicated routing solution like <code>angular/router</code> or <code>vue-router</code>. They allow you to navigate through pages of an application without a full page refresh on every click.</p>"},{"location":"docs/routing/introduction/#problem-statement","title":"Problem statement","text":"<p>When you have a monolithic application, it handles all the routes on its own. When there are two or more applications, they also handle all their routes independently. Since by default, one independent application knows nothing about routes and pages of another independent application. It causes a problem to solve, a routing issue.</p>"},{"location":"docs/routing/introduction/#routing-basics","title":"Routing basics","text":"<p>Before proceeding with details on how the issue is handled by ILC, get familiar with the basics of routing in the micro-frontends and terminology:</p> <ul> <li>Hard navigation describes a page transition where the browser loads the complete HTML for the next page from the server.</li> <li>Soft navigation describes a page transition that is rendered entirely on the client-side, typically by using a client-side router. In this scenario, the client fetches data from the server via API.</li> </ul>"},{"location":"docs/routing/introduction/#solution","title":"Solution","text":""},{"location":"docs/routing/introduction/#common-approaches","title":"Common approaches","text":"<p>There are several approaches to implement navigation. The common ones are described below:</p> <ol> <li>Page transitions happen via plain links, which results in a full page refresh. To proceed with this approach, Team A must know how to link to the pages of Team B and vice versa. No special tooling is required.</li> <li>All transitions inside team boundaries are soft. Hard navigation happens when the user crosses team boundaries. From an architectural perspective, this approach is the same as the first one because Team A still has to know how to link to the pages of Team B (and vice versa) regardless of the details of the internal implementation.</li> </ol> <p></p>"},{"location":"docs/routing/introduction/#ilc-approach","title":"ILC approach","text":"<p>ILC uses a third approach called Unified SPA (Unified Single-page application). It introduces ILC as a central application container that handles page transitions between the teams. In this approach, all the transitions are soft.</p> <p></p> <p>In ILC, you can use one HTML template for all of your applications. With this approach, page load occurs only once (during the first time load), after that all navigation occurs via CSR (client-side rendering).</p> <p>In addition to the fact that all navigation inside the ILC is soft, it also uses two-tiered routing. This approach allows you to specify only the base URL of the application in ILC and you don't need to know the full route to each page of the application. All navigation within the application can be implemented by development teams using their application's tools (for example, react-router, or vue-router). For comparison, in the flat routing approach, you need to specify a full URL of each page of all your applications.</p> <p></p> <p>In the example above, the user opened the <code>/news/latest</code> page URL. ILC checks the first part of the URL (<code>/news/</code>) to determine the associated application. It correlates to the <code>/news/*</code> route configured in ILC. This route contains information about applications that should be loaded on the page and props these applications need to receive. When the application is loaded and mounted to its container DOM node, it also receives the <code>basePath</code> property that should be used by the application's router. The application's router processes the complete URL to find the correct page inside its SPA.</p> <p>You can use native tools (for example <code>&lt;Link&gt;</code> in <code>React router</code>) to navigate between pages within the application, and <code>global link</code> - a link (<code>&lt;a&gt;</code> tag) to navigate between applications.</p> <p>In ILC, as mentioned before, the transition between applications occurs via the <code>&lt;a&gt;</code> tags. To do this, ILC keeps track of all <code>&lt;a&gt;</code> tags on the page and handles clicks on them, provided that:</p> <ol> <li>Tag contains a non-empty <code>href</code>.</li> <li><code>event.PreventDefault</code> does not equal <code>false</code>.</li> <li><code>target</code>does not equal <code>_self</code>.</li> <li>This is not a special url (<code>mailto</code>, <code>tel</code>, etc).</li> </ol> <p>If one of the above points is not met, ILC ignores the processing of the clicks on the link.</p>"},{"location":"docs/routing/introduction/#handle-routes-with-different-html-templates","title":"Handle routes with different HTML templates","text":"<p>Using multiple templates for a single website is generally not recommended, avoid it when possible.</p> <p>However, you may use this approach for cases when you need to create a specific route with its own template. In those cases, there will be \"hard navigation\" (full page refresh, SSR + CSR) when transiting between routes with different templates.</p>"},{"location":"docs/routing/introduction/#conclusion","title":"Conclusion","text":"<p>ILC acts as a wrapper for other applications making all the transitions soft. Furthermore, it uses two-level routing so that teams can configure routing inside their application as they need to. In ILC, you only need to specify the path to the application.</p>"},{"location":"docs/routing/localization_and_trailing_slash/","title":"System settings: i18n and Trailing slash","text":""},{"location":"docs/routing/localization_and_trailing_slash/#i18n","title":"i18n","text":"<p>ILC comes with built-in internationalization support.</p> <p></p> <p>However, ILC only handles localized URLs at the global level. Currently, it supports two routing schemes that can be switched in the <code>i18n.routingStrategy</code> menu:</p> <ol> <li>Prefix except default - prefix all routes with the locale except those of the default locale.</li> <li>Prefix - prefix all routes with the locale</li> </ol> <p>i18n settings allow you to change page language and currency, however, prefixes are used in localization settings only. Currency selection doesn't affect the URL and doesn't add or delete a prefix. In Registry, you specify all the routes without the locale information.</p> <p></p> <p>More details about i18n are available in the Internationalization page.</p>"},{"location":"docs/routing/localization_and_trailing_slash/#trailing-slash","title":"Trailing slash","text":"<p>A trailing slash is a forward slash (<code>/</code>) symbol at the end of a URL. ILC allows you to manage cases with a trailing slash, but the decision to use it is at your discretion, considering personal preference and special cases you may have.</p> <p></p> <p>To manage trailing slash behavior, there are the following options:</p> <ol> <li>Do nothing - No effect at URLs.</li> <li>Redirect to non-trailing slash - It redirects to the URL without a trailing slash at the end.</li> <li>Redirect to trailing slash - It redirects to the URL with a trailing slash at the end.</li> </ol>"},{"location":"docs/routing/route_configuration/","title":"Route configuration","text":""},{"location":"docs/routing/route_configuration/#route-domains","title":"Route domains","text":"<p>ILC can handle requests from multiple domains, so you can use a single ILC instance to handle them instead of rolling out individual instances for every domain.</p> <p>ILC checks the exact match of domain names. It means that <code>secure.example.com</code> is not equal to <code>example.com</code>, and you may need to add the necessary subdomains to handle this case properly.</p> <p></p> <p>!!! note \"\" - Domain name must be without protocol. - Empty <code>Domain Name</code> field means the main app domain. - To add a new domain, go to the Router domains section in the sidebar.</p> <pre><code>    ??? tip \"Add a new domain\"\n        ![ILC registry domains menu](../assets/routes/domain-create.png)\n</code></pre> <p>ILC renders applications for only one domain at the same time. To add one header to several domains, you need to create the same route several times specifying the required domain for each route.</p> <pre><code>For example:\n\n![ILC registry domains example](../assets/routes/domain-example.png)\n\nwhere:\n\n* :fontawesome-solid-square:{ .color-green } - render for the main domain\n* :fontawesome-solid-square:{ .color-red } - render for the `127.0.0.1` domain only\n</code></pre> <p>More information about domains is available in the Multi-domains page.</p>"},{"location":"docs/routing/route_configuration/#route-template","title":"Route template","text":"<p>Template is an HTML file that is used to build the structure of your page. If it is missing in the routing chain, ILC won't be able to render your content properly and will throw an error.</p> <p></p> <p>Important note</p> <p>There must be at least one template in the routing chain.</p> <pre><code>??? tip \"Create a template\"\n    To create a template, go to the **Templates** section in the sidebar.\n\n    ![ILC registry template menu](../assets/routes/template-create.png)\n</code></pre>"},{"location":"docs/routing/route_configuration/#route-metadata","title":"Route metadata","text":"<p>The <code>Metadata</code> field allows you to configure additional route properties that can be used by ILC core or plugins. This field accepts a JSON object with various properties.</p> <p>Some metadata properties are handled by plugins, not by ILC core. ILC supports custom plugins, and you can learn more about them in the ilc-plugins-sdk repository.</p>"},{"location":"docs/routing/route_configuration/#complete-metadata-configuration","title":"Complete metadata configuration","text":"<p>Here's a complete example of route metadata with all supported options:</p> <pre><code>{\n    \"protected\": true,\n    \"canonicalUrl\": \"/products/main\",\n    \"redirect\": {\n        \"location\": \"/domain-search/\",\n        \"code\": 301\n    },\n    \"customProperty\": \"value\"\n}\n</code></pre>"},{"location":"docs/routing/route_configuration/#supported-core-options","title":"Supported core options","text":""},{"location":"docs/routing/route_configuration/#canonicalurl","title":"<code>canonicalUrl</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Purpose: Specifies the canonical URL for the route. This is used for SEO purposes to indicate the preferred URL when multiple URLs might display similar or identical content.</li> <li>Format:<ul> <li>Must be a relative path (e.g., <code>/products/main</code>): Will be combined with the current domain</li> <li>Absolute URLs (starting with <code>http://</code> or <code>https://</code>) are not supported and will be ignored</li> </ul> </li> <li>Behavior with i18n: When using i18n, the canonical URL will be automatically localized based on the current locale.</li> <li>Implementation: ILC automatically adds a <code>&lt;link rel=\"canonical\"&gt;</code> tag to the page's <code>&lt;head&gt;</code> section with the specified URL.</li> </ul> <p>Example:</p> <pre><code>{\n    \"canonicalUrl\": \"/products/main\"\n}\n</code></pre> <p>This will generate the following HTML in the page head:</p> <pre><code>&lt;link rel=\"canonical\" href=\"https://yourdomain.com/products/main\" data-ilc=\"1\" /&gt;\n</code></pre>"},{"location":"docs/routing/route_configuration/#interaction-with-domain-specific-canonical-domain","title":"Interaction with domain-specific canonical domain","text":"<p>When a canonical domain is configured for the Router Domain, it works together with route <code>canonicalUrl</code>:</p> <ul> <li>Request domain: <code>mirror.example.com</code></li> <li>Canonical domain (configured in Router Domains): <code>www.example.com</code></li> <li>Route canonicalUrl: <code>/products/main</code></li> <li>Result: <code>https://www.example.com/products/main</code></li> </ul> <p>If no canonical domain is configured, the request domain is used:</p> <ul> <li>Result: <code>https://mirror.example.com/products/main</code></li> </ul> <p>See Multi-domains canonical domain for more information about configuring canonical domains.</p>"},{"location":"docs/routing/route_configuration/#redirect","title":"<code>redirect</code>","text":"<ul> <li>Type: <code>object</code></li> <li>Purpose: Configures a redirect for the current route to another location. This is useful for URL migrations, SEO improvements, or directing users to the correct page.</li> <li>Properties:<ul> <li><code>location</code> (string): The destination URL to redirect to. Can be a relative path or absolute URL.</li> <li><code>code</code> (number): The HTTP status code for the redirect. Typically 301 (permanent) or 302 (temporary).</li> </ul> </li> <li>Behavior: When a user visits a route with a redirect configuration, they will be automatically redirected to the specified location with the appropriate HTTP status code.</li> </ul> <p>Example:</p> <pre><code>{\n    \"redirect\": {\n        \"location\": \"/domain-search/\",\n        \"code\": 301\n    }\n}\n</code></pre> <p>This will redirect users from the current route to <code>/domain-search/</code> with a 301 (permanent) redirect status code.</p>"},{"location":"docs/routing/route_configuration/#plugin-specific-options","title":"Plugin-specific options","text":""},{"location":"docs/routing/route_configuration/#protected","title":"<code>protected</code>","text":"<ul> <li>Type: <code>boolean</code></li> <li>Purpose: Determines whether the page should be protected. If set to <code>true</code>, access to the protected page will only be granted after the user fulfills the required conditions.</li> <li>Plugin: Transition hooks</li> </ul>"},{"location":"docs/routing/route_configuration/#custom-properties","title":"Custom properties","text":"<p>You can add any custom properties to the metadata object that will be available to your applications through the router. These properties can be used to configure specific behavior for each route in your applications.</p>"},{"location":"docs/routing/route_configuration/#access-the-protected-page","title":"Access the protected page","text":"<p>In the basic scenario, the required condition to access the protected page is to press the <code>confirm</code> button. In real world scenarios, you can set any conditions (for example, authorization form).</p> <p></p> <p>More information about the Transition hooks plugin is available in the ILC transition hooks page.</p>"},{"location":"docs/routing/route_configuration/#slot-configuration","title":"Slot configuration","text":"<p>Slot configuration defines the main settings of a route:</p> <ul> <li>Application.</li> <li>Where the application should be displayed.</li> <li>How critical the application is for the site.</li> <li>Create/change application properties.</li> </ul> <p> </p> <p>If you want to render a page as plain HTML, leave the slot properties empty and ensure that the current route uses the HTML template with no <code>ilc-slot</code> tags.</p>"},{"location":"docs/routing/route_configuration/#configuration","title":"Configuration","text":"<ol> <li> <p>Slot name</p> <p>Slot name refers to the value of the <code>id</code> attribute of the corresponding <code>ilc-slot</code> in the ILC templates. Your application will be rendered inside the <code>ilc-slot</code> with the <code>id</code> that you specify in the <code>Slot name</code>.</p> <pre><code>&lt;/head&gt;\n &lt;body&gt;\n   &lt;ilc-slot id=\"navbar\" /&gt;\n   &lt;ilc-slot id=\"body\" /&gt;\n   &lt;ilc-slot id=\"footer\" /&gt;\n &lt;/body&gt;\n &lt;/html&gt;\n</code></pre> <p>Important note</p> <p>You can have only one application per slot. If you add multiple applications to one slot, only the latter one will be rendered.</p> </li> <li> <p>App name</p> <p>App name refers to the application that will be rendered in the specified slot. Applications in the list are defined in the <code>Apps</code> section in the sidebar.</p> </li> <li> <p>App type</p> <p>There are the following app types:</p> <ul> <li>Primary: set for the vital applications of your site. If the application crashes on the server side, ILC won't render it on the client side, and will immediately render an error.</li> <li>Essential: set for the vital applications for the user (for example, header). If the application crashes on the server side, ILC will try to render it on the client side. It will render an error only if the application crashes on both server and client sides.</li> <li>Regular: set for non-critical applications (for example, footer). If the application crashes on both server and client sides, ILC won't render it on the client side and will ignore errors from it.</li> </ul> </li> <li> <p>Props field</p> <p>Props allow you to configure the application separately for each route. With props, you can override the props specified when creating the application in the Apps section in the sidebar.</p> </li> </ol>"},{"location":"docs/routing/route_matching_patterns/","title":"Route matching patterns","text":""},{"location":"docs/routing/route_matching_patterns/#match-and-cascade-merge","title":"Match and cascade merge","text":""},{"location":"docs/routing/route_matching_patterns/#route-field","title":"Route field","text":"<ul> <li><code>*</code> - Matches any route.</li> <li><code>/</code>- Matches home page only.</li> <li><code>/news/*</code> - Matches <code>/news/</code> route and any subroute (for example, <code>/news/blablabla</code>).</li> <li><code>/wrapper/</code> - Matches only <code>/wrapper/</code> route and ignores any subroute (for example, <code>/wrapper/blablabla</code>).</li> </ul> <p>Important note</p> <p>Route must be unique for each domain.</p> <p>Exception is <code>*</code> - you can use the same order position, provided that the domain names are different.</p>"},{"location":"docs/routing/route_matching_patterns/#order-field","title":"Order field","text":"<p>The <code>order</code> field is an integer value that specifies the order in which the fragments should be fetched when constructing pages. ILC goes through positions from lowest to highest.</p> <p>To specify order position, you can use integer numbers (only) from -\u221e to +\u221e .</p> <p>For more details, refer to the Examples section below.</p> <p>Important note</p> <p>Order positions must be unique for each domain.</p> <p>You can use the same order position, provided that the domain names are different.</p>"},{"location":"docs/routing/route_matching_patterns/#next-field","title":"Next field","text":"<p>The <code>next</code> field is a boolean value that instructs ILC on whether should it move further (<code>true</code>) through the list of applications, or stop (<code>false</code>) after rendering the current one.</p>"},{"location":"docs/routing/route_matching_patterns/#examples","title":"Examples","text":""},{"location":"docs/routing/route_matching_patterns/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the examples, ensure that your routing table looks as follows:</p> <p></p>"},{"location":"docs/routing/route_matching_patterns/#wrapper-route","title":"<code>/wrapper/</code> route","text":"<ol> <li>After configuring your routing table, navigate to the <code>http://localhost:8233/wrapper/</code></li> </ol> <p>ILC side:</p> <ol> <li>ILC starts with the application with the lowest <code>Order pos</code> value (in this case, <code>-100</code>). Its route is <code>*</code>, so it is rendered. The <code>Next</code> field is set to <code>true</code>, so ILC goes further to the next route.</li> <li>ILC moves further to position <code>Order pos -1</code>. It does not render it because the <code>/simple/</code> route does not match the given one.</li> <li>ILC moves further to position <code>Order pos 0</code>. It renders this application because its route is <code>*</code>. The <code>Next</code> field is set to <code>true</code>, so ILC goes further to the next route.</li> <li>The applications with <code>Order pos</code> <code>3</code>, <code>10</code>, <code>20</code>, and <code>30</code> are not rendered because their route does not match the specified one. The <code>Next</code> field is set to <code>true</code>, so ILC goes further to the next route.</li> <li>ILC moves further to position <code>Order pos 40</code>. This is the exact match of the specified route. This application is rendered. The <code>Next</code> field is set to <code>false</code>, so IL\u0421 stops.</li> </ol> <p>As a result, there are 3 rendered applications for both <code>*</code> routes and for <code>/wrapper/</code> route.</p> <p></p> <p></p>"},{"location":"docs/routing/route_matching_patterns/#render-a-page-with-navbar-only","title":"Render a page with navbar only","text":"<p>In this example, you will instruct ILC to render the <code>navbar</code> and skip rendering of the application at the <code>Order pos 0</code> and route <code>*</code>. You will be working with the <code>/wrapper/</code> example route.</p> <p>To do this:</p> <ol> <li>Set the <code>Order pos</code> for the <code>/wrapper/</code> route to any number between <code>-100</code> and <code>0</code>. For example, <code>-2</code>.</li> <li>Make sure that the <code>Next</code> field for the <code>/wrapper/</code> route is set to <code>false</code>.</li> </ol> <p></p> <p>Explanation</p> <p>Since you want to skip rendering of the application that has the <code>Order pos 0</code>, considering that <code>navbar</code> has the <code>Order pos -100</code>, you need to define your <code>/wrapper/</code> route at any place after the <code>navbar</code> but before the application (<code>-100 &lt; number &lt; 0</code>).</p> <p>ILC side:</p> <ol> <li>ILC starts with the application with the lowest <code>Order pos</code> value (in this case, <code>-100</code>). Its route is <code>*</code>, so it is rendered. The <code>Next</code> field is set to <code>true</code>, so ILC goes further to the next route.</li> <li>ILC moves further to position <code>Order pos -2</code>. It renders this application because it is a match. The <code>Next</code> field is set to <code>false</code>, so IL\u0421 stops.</li> </ol> <p></p>"},{"location":"docs/routing/route_matching_patterns/#peopleblablabla-route","title":"<code>/people/blablabla/</code> route","text":"<p>Since ILC registry already contains the <code>/people/*</code> value, ILC renders both <code>*</code> and <code>/people/*</code> routes.</p> <p></p>"},{"location":"docs/routing/route_matching_patterns/#conclusion","title":"Conclusion","text":"<p>As you can see from the examples above, <code>Order pos</code> can be used to flexibly manipulate the content you want to show.</p> <p>A quick recap:</p> <p>Let's say, you have a page with the following elements: <code>application</code>, <code>sidebar</code>, <code>navbar</code>, <code>footer</code>. To skip rendering of a particular element(s), change <code>Order pos</code> of your application accordingly. See the examples below:</p> Render all elementsSkip sidebarSkip sidebar and navbarSkip sidebar, navbar, and footer <ul> <li> <code>footer</code>: <code>Order pos -1000</code></li> <li> <code>navbar</code>: <code>Order pos -100</code></li> <li> <code>sidebar</code>: <code>Order pos 0</code></li> <li> <code>application</code>: <code>Order pos 5</code></li> </ul> <ul> <li> <code>footer</code>: <code>Order pos -1000</code></li> <li> <code>navbar</code>: <code>Order pos -100</code></li> <li> <code>application</code>: <code>Order pos -50</code></li> <li> <code>sidebar</code>: <code>Order pos 0</code></li> </ul> <ul> <li> <code>footer</code>: <code>Order pos -1000</code></li> <li> <code>application</code>: <code>Order pos -200</code></li> <li> <code>navbar</code>: <code>Order pos -100</code></li> <li> <code>sidebar</code>: <code>Order pos 0</code></li> </ul> <ul> <li> <code>application</code>: <code>Order pos -1200</code></li> <li> <code>footer</code>: <code>Order pos -1000</code></li> <li> <code>navbar</code>: <code>Order pos -100</code></li> <li> <code>sidebar</code>: <code>Order pos 0</code></li> </ul>"},{"location":"docs/routing/route_transition_and_animation/","title":"Route transition and animation","text":""},{"location":"docs/routing/route_transition_and_animation/#overview","title":"Overview","text":"<p>As you may have read in intoduction, all transitions in the ILC are soft. It means that you can add, remove, and replace applications on the page without reloading thanks to the use of one HTML template for all pages. This template contains so-called ilc-slots that are used to render applications. (one application per slot at a time).</p> <p>For example:</p> <p>In this example, the routing table looks as follows:</p> <p></p> <p>Whereas the HTML template contains two ilc-slots:</p> <pre><code>&lt;body&gt;\n  &lt;ilc-slot id=\"navbar\" /&gt;\n  &lt;ilc-slot id=\"body\" /&gt;\n&lt;/body&gt;\n</code></pre> <p>Navigate to the <code>/wrapper/</code> route. In this case, ILC will render the application in both slots: the navigation bar () in the <code>navbar</code> slot, and the main app () in the <code>body</code> slot.</p> <p></p> <p>Navigate to the <code>/hooks/</code> route. The application inside the <code>body</code> slot will be replaced, while the navigation bar will stay in place.</p> <p></p> <p>Navigate to the <code>/noheader/</code> route. For this route, there is only one application specified that is rendered inside the <code>body</code> slot. The <code>navbar</code> slot is empty now.</p> <p></p> <p>Routing within applications can be processed natively by application tools instead of the ILC. With this routing, the content will always be located inside the same ILC slot.</p>"},{"location":"docs/routing/route_transition_and_animation/#animation-capabilities","title":"Animation capabilities","text":"<p>Regardless of system optimization or how well your product design is, there will always be a point where the user has to wait. For these cases, ILC has a built-in feature to display a spinner when loading an application. </p>"},{"location":"docs/routing/route_transition_and_animation/#global-spinner","title":"Global spinner","text":"<p>There are the following settings to configure spinner behavior:</p> <ol> <li><code>globalSpinner.enabled</code> - enable or disable the display of the spinner.</li> <li><code>globalSpinner.customHTML</code> - add your custom spinner.</li> </ol> <p>We recommend using more progressive tools like <code>Skeleton loader</code> - a placeholder for the information that is still loading that mimics the look and structure of the entire view.</p>"},{"location":"docs/routing/special_routes/","title":"Error handling in router","text":"<p>\u0421urrently, ILC can handle 404 and 5XX errors only.</p> <p>This document describes the implementation of errors in ILC.</p> <p>Since in the micro frontends, a webpage consists of several fragments, the approach to handling errors differs from that used in monolithic frontends.</p>"},{"location":"docs/routing/special_routes/#404-error","title":"'404' error","text":"<p>To see 404 error routes, use the <code>Show special</code> switcher at the top of the routes page. <code>Special route</code> must be created separately for each domain.</p> <p></p> <p>Unlike simple routes that use composition with the help of the <code>Next</code> property, the special route has its own configuration. It means that you must add the template and all the necessary applications (for example, header, footer) to the <code>Special route</code> slot (see the screenshot below).</p> <p></p> <p>More information about the 404 error is available in the Global error handling page.</p>"},{"location":"docs/routing/special_routes/#5xx-errors","title":"'5XX' errors","text":"<p>ILC render this error as a simple HTML file. This consideration is made to minimize the chances of error occurrence on rendering since if ILC fails, this HTML file will be used by the browser to show an error to the user.</p> <p>The <code>500</code> template acts as the default error template for the main domain.</p> <p></p> <p>To assign different error templates to domains, you must specify the template when creating a domain. See the screenshots below.</p> <p> </p> Preview error <p>In ILC, it is possible to preview the 500 error via the <code>/_ilc/500/</code> route.</p> <p>For example: <code>http://localhost:8233/_ilc/500</code> is the preview route for the demo website.</p> <p>More information about the 5xx errors handling is available in the Global error handling page.</p>"}]}